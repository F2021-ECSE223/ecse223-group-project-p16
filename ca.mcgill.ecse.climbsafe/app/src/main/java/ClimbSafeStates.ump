class Assignment {
  lazy authCode;
  lazy Integer refundPercent;
  
  assignmentStatus {

    Active {
      
      Assigned {
        
        pay(Member member, String aAuthCode) [isAuthCodeValid(aAuthCode)] / {
          makePayment(member, aAuthCode); 
        } -> Paid;

        start(Member member) / {
          banMember(member);
        } -> Assigned;
        
        finish(Member member) / {
          finishTrip(member);
          rejectFinishRequest("Cannot finish a trip which has not started");
        } -> Assigned;
        
      }

      
      Paid {
        
        start(Member member) / {
          startTrip(member);
        } -> Started;

        pay(Member member, String aAuthCode) / {
          makePayment(member, aAuthCode);
          rejectPayment("Trip has already been paid for"); 
        } -> Paid;

        finish(Member member) / {
          finishTrip(member);
          String error = "Cannot finish a trip which has not started";
          rejectFinishRequest(error);
        } -> Paid;
        
      }

      
      Started {
        
        finish(Member member) / {
          finishTrip(member); 
        } -> Finished;
        
        pay(Member member, String aAuthCode) / {
          makePayment(member, aAuthCode);
          rejectPayment("Trip has already been paid for"); 
        } -> Started;
      }
      

      // transitions out of Active composite state
      cancel() / {
        cancelTrip(member); 
      } -> Cancelled;
      
    }


    Finished {

      pay(Member member, String aAuthCode) / {
      	
        makePayment(member, aAuthCode);
        String error = "Cannot pay for a trip which has finished";
        rejectPayment(error); 
      } -> Finished;

      start(Member member) / {
        String error = "Cannot start a trip which has finished";
        rejectStartRequest(error);
      } -> Finished;

      cancel() / {
        cancelTrip(member);
        String error = "Cannot cancel a trip which has finished";
        rejectCancelRequest(error);
      } -> Finished;

    }

    
    Cancelled {
      
      pay(Member member, String aAuthCode) / {
        makePayment(member, aAuthCode);
        error = "Cannot pay for a trip which has been cancelled";
        rejectPayment(error); 
      } -> Cancelled;

      start(Member member) / {
        error = "Cannot start a trip which has been cancelled";
        rejectStartRequest(error);
      } -> Cancelled;

      finish(Member member) / {
        finishTrip(member);
        String error = "Cannot finish a trip which has been cancelled";
        rejectFinishRequest(error);
      } -> Cancelled;
      
    }
  }

  private boolean isAuthCodeValid(String aAuthCode){
    if (aAuthCode.isEmpty()){
      return false;
    }
    else if (aAuthCode == null){
      return false;
    }
    return true;
  }
  
  private boolean isMemberValid(Member member){
    return member.getMemberStatusFullName().equals("NotBanned");
  }

  private void makePayment(Member member, String aAuthCode){
    if (!isMemberValid(member)){
      throw new RuntimeException("Cannot pay for the trip due to a ban");
    }
    setAuthCode(aAuthCode);
  }

  private void startTrip(Member member){
    if (!isMemberValid(member)){
      throw new RuntimeException("Cannot start the trip due to a ban");
    }
  }
  private void cancelTrip(Member member){
	
    if (!isMemberValid(member)){
      throw new RuntimeException("Cannot cancel the trip due to a ban");
    }
  
  	switch(this.assignmentStatusActive) {
  	  case Paid:
  	  	setRefundPercent(50);
  	  	break;
  	  case Started:
  	  	setRefundPercent(10);
  	  	break;	

  }

  private void finishTrip(Member member){
    if (!isMemberValid(member)){
      throw new RuntimeException("Cannot finish the trip due to a ban");
    }
  }
  
  private void banMember(Member member){
    member.ban();
  }

  private void rejectPayment(String error){

    throw new RuntimeException(error);
  }

  private void rejectFinishRequest(String error){
    throw new RuntimeException(error);
  }

  private void rejectStartRequest(String error){
    throw new RuntimeException(error);
  }

  private void rejectCancelRequest(String error){
    throw new RuntimeException(error);
  }

}

class Member{
  memberStatus{
    NotBanned{
      ban() -> Banned;

    }
    Banned{}
  }
  
}
